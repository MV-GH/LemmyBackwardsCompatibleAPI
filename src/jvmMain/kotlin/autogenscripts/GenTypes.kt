package autogenscripts

import coreKtor
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.util.cio.*
import io.ktor.utils.io.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.util.zip.ZipFile

const val rootPath = "src/commonMain/kotlin/"
const val rootPackagePath = ""
const val rootPackage = ""
const val customDataTypesPackage = "dto."

// These were accidentally added to the types, but are not actually exported by the API
val propsThatShouldNotBeAdded = listOf("followers_url", "inbox_url")

val filesThatShouldNotBeAdded = setOf("others.ts", "DeleteAccountResponse.ts", "PasswordResetResponse.ts", "VerifyEmailResponse.ts")

fun getTypesPath(version: String, temp: Boolean = true) = "$rootPath$rootPackagePath$version/datatypes" + if (temp) "/temp" else ""

fun isInteger(l: String) = !l.contains(Regex("""\b(hot_rank|hot_rank_active)\b"""))

fun getDownloadLink(tag: String) = "https://github.com/LemmyNet/lemmy-js-client/archive/refs/tags/$tag.zip"

// Requires that dukat is installed https://github.com/Kotlin/dukat
// Rewrites the TS types to Kotlin types
suspend fun downloadTypes(version: String, vShort: String) {
    val temp = File("temp")
    temp.mkdir()

    val lemmyJsClient = File("temp", "lemmy-js.zip")

    coreKtor.get(getDownloadLink(version))
        .bodyAsChannel()
        .copyAndClose(lemmyJsClient.writeChannel())

    val dest = File(getTypesPath(vShort))
    dest.mkdirs()

    withContext(Dispatchers.IO) {
        val zip = ZipFile(lemmyJsClient)
        val path = "lemmy-js-client-$version/src/types"

        for (entry in zip.entries()) {
            if (entry.name.startsWith(path) && !entry.isDirectory) {
                val name = entry.name.substring(path.length)
                val f = File(dest, name)
                f.createNewFile()
                f.writeBytes(zip.getInputStream(entry).readAllBytes())
            }
        }

        val datatypes = File(getTypesPath(vShort, false))

        val command = mutableListOf(
            "cmd.exe",
            "/c",
            "dukat",
        )

        // Adds all the ts files to the command, "*.ts" does not work and causes an error
        for (f in dest.listFiles()!!) {
            if (f.name.endsWith(".ts") && f.isFile() && filesThatShouldNotBeAdded.contains(f.name).not()) {
                command.add("temp/${f.name}")
            }
        }

        val pb = ProcessBuilder(command)
        pb.directory(datatypes)
        val proc = pb.start()

        println(String(proc.inputStream.readAllBytes()))

        for (typeFile in datatypes.listFiles()!!) {
            if (typeFile.name.startsWith("lib")) {
                typeFile.delete()
            } else if (typeFile.name.endsWith(".kt") && typeFile.isFile()) {
                val fileName = typeFile.name.substringBefore(".")
                val f = File(datatypes, "$fileName.kt")
                f.createNewFile()

                // Add header for each file
                f.writeText(
                    """
                    package $rootPackage$vShort.datatypes
                    
                    """.trimIndent(),
                )

                var imports = ""

                // typealiases are not serializable
                if (!typeFile.readText().contains("typealias")) {
                    imports += "import kotlinx.serialization.Serializable\n\n@Serializable"
                }

                val lines = typeFile.readText()
                    .split(Regex("\r?\n"))
                    .drop(15) // Remove weird dukat imports
                    .filter { !it.contains("definedExternally") } // Remove these weird getters and setters
                    .filter { line -> !propsThatShouldNotBeAdded.any { line.contains(it) } } // Remove props that should not be added
                    .map { line ->
                        // Convert interface to data class
                        var k = line.replace("interface ", "data class ")
                            .replace(" {", "(")
                            .replace("}", ")")

                        if (k.contains("?") && !k.contains("=")) {
                            k += " = null"
                        }

                        if (k.contains(":")) {
                            k += ","
                        }

                        // Better align with kotlin conventions
                        k = k.replace(Regex("""\b(var)\b"""), "val")
                            .replace(Regex("""\b(Array)\b"""), "List")

                        k = if (isInteger(k)) {
                            k.replace(Regex("""\b(Number)\b"""), "Int")
                        } else {
                            k.replace(Regex("""\b(Number)\b"""), "Float")
                        }

                        // Add the CustomDataTypes, that aren't autogenerated
                        k = k.replace(Regex("listing_type: String")) { _ ->
                            imports = "import $rootPackage${customDataTypesPackage}ListingType\n$imports"
                            "listing_type: ListingType"
                        }
                        k = when (fileName) {
                            "SearchResponse", "Search" -> {
                                k.replace(Regex("type_: String")) { _ ->
                                    imports = "import $rootPackage${customDataTypesPackage}SearchType\n$imports"
                                    "type_: SearchType"
                                }
                            }

                            "GetModlog" -> {
                                k.replace(Regex("type_: String")) { _ ->
                                    imports = "import $rootPackage${customDataTypesPackage}ModlogActionType\n$imports"
                                    "type_: ModlogActionType"
                                }
                            }

                            else -> {
                                k.replace(Regex("type_: String")) { _ ->
                                    imports = "import $rootPackage${customDataTypesPackage}ListingType\n$imports"
                                    "type_: ListingType"
                                }
                            }
                        }

                        if (fileName == "GetComments" || fileName == "GetPersonMentions" || fileName == "GetReplies") {
                            k.replace(Regex("sort: String")) { _ ->
                                imports = "import $rootPackage${customDataTypesPackage}CommentSortType\n$imports"
                                "sort: CommentSortType"
                            }
                        } else {
                            k.replace(Regex("sort: String")) { _ ->
                                imports = "import $rootPackage${customDataTypesPackage}SortType\n$imports"
                                "sort: SortType"
                            }.replace(Regex("sort_type: String")) { _ ->
                                imports = "import $rootPackage${customDataTypesPackage}SortType\n$imports"
                                "sort_type: SortType"
                            }
                        }
                            .replace(Regex("registration_mode: String")) { _ ->
                                imports = "import $rootPackage${customDataTypesPackage}RegistrationMode\n$imports"
                                "registration_mode: RegistrationMode"
                            }
                            .replace(Regex("subscribed: String")) { _ ->
                                imports = "import $rootPackage${customDataTypesPackage}SubscribedType\n$imports"
                                "subscribed: SubscribedType"
                            }
                            .replace(Regex("feature_type: String")) { _ ->
                                imports = "import $rootPackage${customDataTypesPackage}PostFeatureType\n$imports"
                                "feature_type: PostFeatureType"
                            }
                            .replace(Regex("post_listing_mode: String")) { _ ->
                                imports = "import $rootPackage${customDataTypesPackage}PostListingMode\n$imports"
                                "post_listing_mode: PostListingMode"
                            }

                        // TODO fix custom others types
                    }

                if (imports != "") {
                    f.appendText("\n")
                    f.appendText(imports)
                }

                f.appendText(lines.joinToString("\n"))

                // Must end in a newline to pass formatter
                if (lines.last() != "" && lines.last() != "\r") {
                    f.appendText("\n")
                }

                typeFile.delete()
            }
        }

        dest.deleteRecursively()
    }
    temp.deleteRecursively()
}

suspend fun main() {
    downloadTypes("0.19.0-rc.13", "v0x19")
}

// TODO Site.inbox_url
